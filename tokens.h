#ifndef TOKENS_H
#define TOKENS_H

enum TokenType
{
    // Keywords  
    KEYWORD_INT = 1,
    KEYWORD_CHAR,
    KEYWORD_FLOAT,
    KEYWORD_DOUBLE,
    KEYWORD_VOID,
    KEYWORD_IF,
    KEYWORD_ELSE,
    KEYWORD_FOR,
    KEYWORD_WHILE,
    KEYWORD_RETURN,
    KEYWORD_BREAK,
    KEYWORD_CONTINUE,
    KEYWORD_DO,
    KEYWORD_SWITCH,
    KEYWORD_CASE,
    KEYWORD_DEFAULT,
    KEYWORD_GOTO,
    KEYWORD_ENUM,
    KEYWORD_STRUCT,
    KEYWORD_UNION,
    KEYWORD_TYPEDEF,
    KEYWORD_STATIC,
    KEYWORD_AUTO,
    KEYWORD_CONST,
    KEYWORD_SIZEOF,
    KEYWORD_CLASS,
    KEYWORD_PUBLIC,
    KEYWORD_PRIVATE,
    KEYWORD_PROTECTED,
    KEYWORD_NEW,
    KEYWORD_DELETE,
    KEYWORD_USING,
    KEYWORD_NAMESPACE,
    KEYWORD_BOOL, 
    KEYWORD_LONG,

    // Literals treated as keywords
    KEYWORD_TRUE,
    KEYWORD_FALSE,

    // Identifiers and literals
    IDENTIFIER,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    CHAR_LITERAL,
    STRING_LITERAL,

    // Operators
    OP_PLUS,
    OP_MINUS,
    OP_MULTIPLY,
    OP_DIVIDE,
    OP_MODULO,
    OP_INCREMENT,
    OP_DECREMENT,
    OP_ASSIGN,
    OP_ADD_ASSIGN,
    OP_SUB_ASSIGN,
    OP_MUL_ASSIGN,
    OP_DIV_ASSIGN,
    OP_MOD_ASSIGN,
    OP_LSHIFT,
    OP_RSHIFT,
    OP_AND,
    OP_OR,
    OP_XOR,
    OP_NOT,
    OP_EQUAL,
    OP_NOT_EQUAL,
    OP_LESS_THAN,
    OP_GREATER_THAN,
    OP_LESS_THAN_EQUAL,
    OP_GREATER_THAN_EQUAL,
    OP_LOGICAL_AND,
    OP_LOGICAL_OR,
    OP_LOGICAL_NOT,
    OP_BITWISE_AND,
    OP_BITWISE_OR,
    OP_BITWISE_XOR,
    OP_BITWISE_NOT,

    // Punctuation and Delimiters
    SEMICOLON,
    COMMA,
    OPEN_PARENTHESIS,
    CLOSE_PARENTHESIS,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_CURLY_BRACKET,
    CLOSE_CURLY_BRACKET,
    COLON,
    POINTER_ARROW,
    DOT,
    REFERENCE_AMPERSAND,
    POINTER_STAR,
    QUESTION_MARK,

    // Preprocessor and Comments
    PREPROCESSOR_DIRECTIVE,
    SINGLE_LINE_COMMENT,
    MULTI_LINE_COMMENT,
    NEWLINE,
    WHITESPACE,
    
    // Special tokens
    ERROR_TOKEN,
    UNKNOWN,
    END_OF_FILE
};

// Map from enum values to human-readable strings {index corresponds to the enum value}
const char* const token_names[] = {
    "KEYWORD_INT",
    "KEYWORD_CHAR",
    "KEYWORD_FLOAT",
    "KEYWORD_DOUBLE",
    "KEYWORD_VOID",
    "KEYWORD_IF",
    "KEYWORD_ELSE",
    "KEYWORD_FOR",
    "KEYWORD_WHILE",
    "KEYWORD_RETURN",
    "KEYWORD_BREAK",
    "KEYWORD_CONTINUE",
    "KEYWORD_DO",
    "KEYWORD_SWITCH",
    "KEYWORD_CASE",
    "KEYWORD_DEFAULT",
    "KEYWORD_GOTO",
    "KEYWORD_ENUM",
    "KEYWORD_STRUCT",
    "KEYWORD_UNION",
    "KEYWORD_TYPEDEF",
    "KEYWORD_STATIC",
    "KEYWORD_AUTO",
    "KEYWORD_CONST",
    "KEYWORD_SIZEOF",
    "KEYWORD_CLASS",
    "KEYWORD_PUBLIC",
    "KEYWORD_PRIVATE",
    "KEYWORD_PROTECTED",
    "KEYWORD_NEW",
    "KEYWORD_DELETE",
    "KEYWORD_USING",
    "KEYWORD_NAMESPACE",
    "KEYWORD_BOOL",
    "KEYWORD_LONG",
    "KEYWORD_TRUE",
    "KEYWORD_FALSE",
    "IDENTIFIER",
    "INTEGER_LITERAL",
    "FLOAT_LITERAL",
    "CHAR_LITERAL",
    "STRING_LITERAL",
    "OP_PLUS",
    "OP_MINUS",
    "OP_MULTIPLY",
    "OP_DIVIDE",
    "OP_MODULO",
    "OP_INCREMENT",
    "OP_DECREMENT",
    "OP_ASSIGN",
    "OP_ADD_ASSIGN",
    "OP_SUB_ASSIGN",
    "OP_MUL_ASSIGN",
    "OP_DIV_ASSIGN",
    "OP_MOD_ASSIGN",
    "OP_LSHIFT",
    "OP_RSHIFT",
    "OP_AND",
    "OP_OR",
    "OP_XOR",
    "OP_NOT",
    "OP_EQUAL",
    "OP_NOT_EQUAL",
    "OP_LESS_THAN",
    "OP_GREATER_THAN",
    "OP_LESS_THAN_EQUAL",
    "OP_GREATER_THAN_EQUAL",
    "OP_LOGICAL_AND",
    "OP_LOGICAL_OR",
    "OP_LOGICAL_NOT",
    "OP_BITWISE_AND",
    "OP_BITWISE_OR",
    "OP_BITWISE_XOR",
    "OP_BITWISE_NOT",
    "SEMICOLON",
    "COMMA",
    "OPEN_PARENTHESIS",
    "CLOSE_PARENTHESIS",
    "OPEN_BRACKET",
    "CLOSE_BRACKET",
    "OPEN_CURLY_BRACKET",
    "CLOSE_CURLY_BRACKET",
    "COLON",
    "POINTER_ARROW",
    "DOT",
    "REFERENCE_AMPERSAND",
    "POINTER_STAR",
    "QUESTION_MARK",
    "PREPROCESSOR_DIRECTIVE",
    "SINGLE_LINE_COMMENT",
    "MULTI_LINE_COMMENT",
    "NEWLINE",
    "WHITESPACE",
    "ERROR_TOKEN",
    "UNKNOWN",
    "END_OF_FILE"
};

// Function to convert token enum to string
inline const char* token_to_string(TokenType token) {
    if (token >= 1 && token <= END_OF_FILE) {
        return token_names[token - 1];  // Adjust for 0-based array indexing
    }
    return "UNKNOWN";
}

#endif